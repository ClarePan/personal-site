---
title: "Animated Directional Chord Diagrams"
author: "Guy Abel"
date: "2018-02-10"
tags: ["R"]
draft: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background

A little while ago my paper in *International Migration Review* on global migration flow estimates came out [online](http://guyabel.com/publication/global-migration-estimates-by-gender/). The paper includes a number of directional chord diagrams to visualize the estimates.

Recently I have been playing around `tweenr` and the `magick` packages for animated population pyramids. In this post I attempt to show how to use these packages to produce animated directional chord diagrams of global migration flow estimates


## Data Prep

The first step is to read into R two data frames. 

  1. Time series of migration flows for animation:
```{r, message=FALSE}
# install.packages("migest")
library(tidyverse)
d0 <- read_csv(system.file("imr", "reg_flow.csv", package = "migest"))
d0 
```

  2. Some meta data for chord diagram plots:
```{r, message=FALSE}
d1 <- read_csv(system.file("vidwp", "reg_plot.csv", package = "migest"))
d1
```

n.b. The data are in my `migest` package. If you wish to run the code yourself uncomment the first line of code above

## Tween Data

The next step is to tween the data by migration corridor. 

```{r, message=FALSE}
library(tweenr)

d2 <- d0 %>%
  mutate(corridor = paste(orig_reg, dest_reg, sep = " -> ")) %>%
  select(corridor, year0, flow) %>%
  mutate(ease = "linear") %>%
  tween_elements(time = "year0", group = "corridor", ease = "ease", nframes = 100) %>%
  tbl_df()
d2
```

This creates larger data frame than `d0`, with 100 counts for each corridor over the time period (in the original data there are only 11, one for each five-year period). 

Then some further minor data wrangling are required to ready the data for plotting, primarily the first three columns in the data must correspond to the origin, destination and flow; the format required by the `chordDiagram` function when using a data frame.

```{r, message=FALSE}
d2 <- d2 %>%
  separate(col = .group, into = c("orig_reg", "dest_reg"), sep = " -> ") %>%
  select(orig_reg, dest_reg, flow, everything()) %>%
  mutate(flow = flow/1e06)
d2
```


## Plots for Each Frame

Now the data is in the correct format, you can use a `for` loop to cycle through the tweend data to produce chord diagram plots for each frame. The argument settings I used here followed pretty much the same as those explained in the comments of the `migest` [demo](https://github.com/gjabel/migest/blob/master/demo/cfplot_reg2.R).

```{r, message=FALSE, eval=FALSE}
# create a directory to store the individual plots
dir.create("./plot-gif/")

library(circlize)
for(f in unique(d2$.frame)){
  # open a PNG plotting device
  png(file = paste0("./plot-gif/cf", f, ".png"), height = 7, width = 7, 
      units = "in", res = 500)
  
  # intialise the circos plot
  circos.clear()
  par(mar = rep(0, 4), cex=1)
  circos.par(start.degree = 90, track.margin=c(-0.1, 0.1), 
             gap.degree = 4, points.overflow.warning = FALSE)

  # plot the chord diagram
  chordDiagram(x = filter(d2, .frame == f), directional = 1, order = d1$region,
               grid.col = d1$col1, annotationTrack = "grid",
               transparency = 0.25,  annotationTrackHeight = c(0.05, 0.1),
               direction.type = c("diffHeight", "arrows"), link.arr.type = "big.arrow",
               diffHeight  = -0.04, link.sort = TRUE, link.largest.ontop = TRUE)
  
  # add labels and axis
  circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    sector.index = get.cell.meta.data("sector.index")
    reg1 = d1 %>% filter(region == sector.index) %>% pull(reg1)
    reg2 = d1 %>% filter(region == sector.index) %>% pull(reg2)
    
    circos.text(x = mean(xlim), y = ifelse(is.na(reg2), 5.75, 7), 
                labels = reg1, facing = "bending", cex = 1.1)
    circos.text(x = mean(xlim), y = 4.75, labels = reg2, facing = "bending", cex = 1.1)
    circos.axis(h = "top", labels.away.percentage = 0.2, labels.niceFacing = FALSE, 
                labels.cex = 0.8, minor.ticks = 1, 
                major.at = seq(from = 0, to = xlim[2], by = ifelse(xlim[2]>15, 4, 2)))
  })
  
  # close plotting device
  dev.off()
}
```

## Creating a GIF

Using the `magick` package a GIF can be created by using the code below to 

 1. Read in an initial plot and then combine together all other images created above
 2. Scale the combined images
 3. Animate the combined images and save as a `.gif`
 
```{r, message=FALSE, eval=FALSE}
library(magick)

img <- image_read(path = "./plot_gif/cf0.png")
for(f in unique(d2$.frame)[-1]){
  img0 <- image_read(path = paste0("./plot_gif/cf",y,".png"))
  img <- c(img, img0)
  message(f)
}

img1 <- image_scale(image = img, geometry = "720x720")

ani0 <- image_animate(image = img1, fps = 10)
image_write(image = ani0, path = "./plot_gif/ani1.gif")
```

This gives an output much like this minus the additional details in the corners:
![ ](/img/abel-ani10-gf-dist.gif)

(might take a few seconds to fully load)

## Fixing Scales in Chord Diagrams

Whilst the plot above allows comparisons of the distributions of flows overtime it is more difficult to compare volumes. For such comparisons, Zuguang [suggests](http://zuguang.de/circlize_book/book/advanced-usage-of-chorddiagram.html#compare-two-chord-diagrams) scaling the gaps between the sectors on the outside of the chord diagram. I wrote a little function that can do this for flow data arranged in a tidy format;

```{r}
scale_gap <- function(flow_m, flow_max, gap_at_max = 1, gaps = NULL) {
  p <- flow_m / flow_max
  if(length(gap_at_max) == 1 & !is.null(gaps)) {
    gap_at_max <- rep(gap_at_max, gaps)
  }
  gap_degree <- (360 - sum(gap_at_max)) * (1 - p)
  gap_m <- (gap_degree + sum(gap_at_max))/gaps
  return(gap_m)
}
```
where 

* `flow_m` is the size of total flows in the matrix for the given year being re-scaled.
* `flow_max` is the maximum size of the flow matrix over all years
* `gap_at_max` is the size in degrees of the gaps in the flow matrix in the year where the flows are at their all time maximum.
* `gaps` is the number of gaps in the chord diagram (i.e. the number of regions).
  
  
The function can be used to derive the size of gaps in each frame for a new animated GIF.
```{r}
d3 <- d2 %>%
  group_by(.frame) %>%
  summarise(flow = sum(flow)) %>%
  mutate(gaps = scale_gap(flow_m = flow, flow_max = max(.$flow), 
                          gap_at_max = 4, gaps = 9))

d3
```

The calculations in `d3` can then be plugged into the `for` loop above, where the `circos.par()` function is replaced by

```{r, message=FALSE, eval=FALSE}
circos.par(start.degree = 90, track.margin = c(-0.1, 0.1),
           gap.degree = filter(d3, .frame == f)$gaps, 
           points.overflow.warning = FALSE)
```

Once the for loop has produced a new set of images, the same code to produce the GIF file can be run to obtain the animated chord diagrams with changing gaps;

![ ](/img/abel-ani10-gf-gap.gif)

I am not convinced that this is the best way to compare volumes of chord diagrams when using animations. The sectors of all regions - bar North America - are changing places making it hard follow their changes over time. 

Fortunately there is new `xlim` option in `chordDiagram` that can be used to fix then lengths of the x-axis for each sector using a named vector. In the context of producing an animation, the historic maximum migration flows (of combined immigration and emigration flows) in each region could be used. These can be calculated as 

```{r, message=FALSE}
library(magrittr)

reg_max <- d2 %>%
  group_by(.frame, orig_reg) %>%
  mutate(tot_out = sum(flow)) %>%
  group_by(.frame, dest_reg) %>%
  mutate(tot_in = sum(flow)) %>%
  filter(orig_reg == dest_reg) %>%
  mutate(tot = tot_in + tot_out) %>%
  mutate(reg = orig_reg) %>%
  group_by(reg) %>%
  summarise(tot_max = max(tot)) %$%
  'names<-'(tot_max, reg)

reg_max
```

The `reg_max` object can then be used in the `chordDiagram` function call in the `for` loop above, replacing the original call with 

```{r, message=FALSE, eval=FALSE}
chordDiagram(x = filter(d2, .frame == f), directional = 1, order = d1$region,
             grid.col = d1$col1, annotationTrack = "grid",
             transparency = 0.25,  annotationTrackHeight = c(0.05, 0.1),
             direction.type = c("diffHeight", "arrows"), link.arr.type = "big.arrow",
             diffHeight  = -0.04, link.sort = TRUE, link.largest.ontop = TRUE, 
             xlim = reg_max)

```

Running the complete code - the adapted `for` loop to produce the images and then the `magick` functions to compile the GIF - results in the following animation:

![ ](/img/abel-ani10-gf-fix.gif)

